[{"title":"clash配置-轮询|散列模式","path":"/posts/18615.html","content":"tags: [‘clash’] categories: ‘经验教程’ # 一、在 clash 配置页面配置预处理配置 12345678910111213141516171819parsers: - reg: &#x27;slbable$&#x27; yaml: append-proxy-groups: - name: ⚖️ 负载均衡-散列 type: load-balance url: &#x27;http://www.google.com/generate_204&#x27; interval: 300 strategy: consistent-hashing - name: ⚖️ 负载均衡-轮询 type: load-balance url: &#x27;http://www.google.com/generate_204&#x27; interval: 300 strategy: round-robin commands: - proxy-groups.⚖️ 负载均衡-散列.proxies=[]proxyNames - proxy-groups.0.proxies.0+⚖️ 负载均衡-散列 - proxy-groups.⚖️ 负载均衡-轮询.proxies=[]proxyNames - proxy-groups.0.proxies.0+⚖️ 负载均衡-轮询 # 二、重新下载配置文件 在配置 url 尾部添加 #slbable ，下载完成即可选择轮询与散列模式。"},{"title":"基于Hexo框架语雀文章博客模板","path":"/posts/57474.html","content":"tags: [‘GitHub’,‘Actions’] categories: ‘精选推荐’ sticky: ‘10’ 跳转仓库:haysalan/hexo-yuque-template # 特点 支持在线一键部署或更新博客 支持拉取语雀文章自动更新博客内容 支持自定义 github actons 或 gitee 工作流 高度可配置，支持自定义部署脚本 # 使用 # 第一步 新建仓库 新建两个仓库 一个私有仓库（名称随意）用于存放 hexo 博客配置等文件 一个开源仓库 yourname.github.io （替换成你的用户名） # 第二步 配置私有仓库环境变量 1.github 个人设置创建 token 给与 workflow 权限以及无时间期限。 2. 将 github token 配置到你的私有仓库中。名称需一致。 3. 进入语雀网页版个人设置，获取语雀 token（现在需要超级会员才能创建，有之前创建的好的可直接使用） 4. 将语雀 token 配置到私有仓库中 名称需一致。 # 第三步 修改 actions 目录 .github/workflows/blog-update.yml 将其中的 PUBLISH_REPOSITORY 修改为你的开源仓库路径。 目录： actions/gitee-sync.yml actions 目录下存放开源仓库的工作流，用于在开源仓库触发执行。 gitee-sync.yml 基于 yanglbme /gitee-pages-action 根据注释就行配置即可。 gitee-sync.yml 用于同步 github pages 同步到 gitee pages 可自动更新 gitee pages 无需 gitee pages pro 。 # 第四步 自定义部署 默认使用 anzhiyu 主题，可自行更换。 安装 hexo 主题或依赖请修改 blog-update.yml 。 构建博客静态文件前后指令添加请修改 script/generate.sh 。 # 预览 博客预览： https://haysalan.github.io/ 博客模板：https://github.com/haysalan/hexo-yuque-template github：https://github.com/Alanhays"},{"title":"精选网络资源&疑难杂症记录","path":"/posts/52888.html","content":"1 1&#123;% note blue &#x27;anzhiyufont anzhiyu-icon-bullhorn&#x27; simple %&#125;需要什么可在下方评论，如找到会新增，不定期更;所有资源均来自网络收集，如有侵权联系我删除！&#123;% endnote %&#125; # windows # 日常使用 360 驱动大师纯净版 2.0.0.2000.exe.zip PixPin_1.0.9.1_Setup - 截图工具.zip 右键菜单编辑工具.zip 图吧工具箱.zip window 关闭自动更新.zip TrafficMonitor - 任务栏信息.zip IDM-Activation-Script-zh-cn.zip Clash-0.20.39.zip 3DP_Net_v2101 - 离线网卡驱动安装.zip # 逆向开发 IDA_Pro_v8.3_Portable.zip IDA_Pro_v7.5_Portable.zip TyporaCrack-main.zip adb-fastboot.zip jadx-1.4.7.zip GDA3.97pro_patch.zip jetbra-IDE 激活.zip fastgithub_win-x64-github 加速.zip ReRes_JS 替换.zip # 镜像文件 # 疑难杂症 # Linux # 疑难杂症 # Vmware 虚拟机Ubuntu 网络图标消失 Bug 12sudo nmcli network offsudo nmcli network on"},{"title":"破解tap验证和绕过实名认证","path":"/posts/50605.html","content":"tags: [‘入门级’] categories: ‘逆向分析’ # 案例目标 去除账号验证 去除实名认证 # 环境准备 MT 管理器 / NP 管理器 JEB/jadx（非必须） 模拟器 / 安卓手机 root （否） 目标 APP # 破解步骤 # 绕过账号验证 开启 MT 管理器的 Activity 记录功能 启动成功后打开我们需要破解的 APP，他会启动游戏平台验证账号，我们回到游戏就会看到下面的页面。 进入 MT 管理器查看记录，最后的一个活动是 com.txxxxx.pay.sdk.library.TxxAlertDialog$1，那我们从它开始入手。 找到这个类 com.txxxxx.pay.sdk.library.TxxAlertDialog 我们得到 new 它的地方。 进入并分析一下。 搜索一下哪里调用了销毁弹窗，验证通过必定需要销毁，找起来更快。 进入分析一下。 看看哪里还个调用了 这里我验证过了，修改它们即可去除验证。 快速定位关键字 checkLicense = licensed (不出意外只有一个结果) 然后搜索定位函数 checkLicense 在smali代码中修改对应的值就能去除验证了。 重新签名安装后启动看看效果吧。 # 绕过实名认证 开启 MT 管理器的Activity 记录功能，然后启动 APP 弹出实名弹窗之后回到 MT 管理器，可以看到只有一个 Activity -&gt; com.lixxthgame.abi.UnityPlayerActivity 在 UnityPlayerActivity 中并没发现什么可疑的地方，那就得找新的办法了。 我们来试试新的关键字 “identify”，需要实名认证，估计会使用这个单词。 看看这个 IdentifyHelp 类是干什么用的。 IdentifyHelp 中有个方法 CompareTimeUp18 翻译过来就是 对比年龄到 18（估计是用出生日期和当前时间对比） 看看那些地方调用了 CompareTimeUp18 选择第一个，进入到方法 antiAddication，分析一下。 进入 setBigMan 或 setIdenfity 中 将 isBigMan 和 isIdenfity 的初始值置为 true 即可去实名认证了。 在smali代码中修改对应的值就能去除验证了。 快速定位关键字 LoaclUser&#123;name= (不出意外只有一个结果) 搜索定位 isIdenfity"},{"title":"Build Nodejs 环境配置","path":"/posts/38694.html","content":"tags: [‘nodejs’,‘build’] categories: ‘经验教程’ # 前言 对于 js 补浏览器环境时遇到一些 js 无法实现的环境，那么就需要修改 node 源码来实现，本文简单复述一下 Build Node 所需要的环境及配置，推荐直接看官方文档。 # windows 10/11 # 环境准备 windows 部分官方教程（推荐） # 一、Python 环境 安装好 python 并且配置环境变量，官网下载（点击下载）我使用的版本是 3.8.0，低版本不知道是否可用，如果第一次安装 Python 建议安装 3.8.0 及以上。 如果下载速度慢，可点击链接（密码：h85c）下载我拷贝到蓝奏云文件。 # 二、Visual Studio Installer 安装 C++/.NET 环境有两个可选方案 1. 安装 Visual Studio 2022 并且勾选 “使用 C++ 进行桌面开发” 和 “.NET 桌面生成工具” 进行环境安装。(推荐) 2. 安装构建工具打开后自动安装 “C++ 构建工具” 环境等待安装完成后打开 Visual Studio Installer 勾选“.NET 桌面生成工具” 进行环境安装。 # 三、NetWide 汇编程序 点击这里下载后安装即可，安装是一直点 next 即可。 我安装的版本是 nasm-2.16.02rc6，其他版本选择点击这里 # 下载 Node 源码 官方教程使用 Git Bash 来进行下载， Git for Windows 下载安装。记得配置环境变量。 12git clone https://github.com/nodejs/node.gitcd node 由于 node 源码 400m 比较大，我选择进入Nodejs 官网进行源码下载，当然使用你喜欢的方式即可。 # Build Node 进入到 node 源码根目录，例如我这里需要进入到 nodes/node-v20.10.0 开始构建 构建后会在Release文件夹下生成构建好的node.exe文件 1.\\vcbuild 进行测试 1.\\vcbuild test 测试 Node.js 是否正确构建 1Release ode -e &quot;console.log(&#x27;Hello from Node.js&#x27;, process.version)&quot;"},{"title":"学习逆向过程中的一些问题与其解决办法","path":"/posts/60184.html","content":"tags: [‘思路’] categories: ‘经验教程’ sticky: ‘9’ # 前言 学习逆向过程中的一些问题与其解决办法，当然还有大佬们文章内提到的，整理出来方便翻阅，持续更新。 1&#123;% tip key %&#125;当然大家有什么问题也可在下方评论，如有解决本文问题的方法还请不吝赐教，在此感谢鞠躬！&#123;% endtip %&#125; # 参考资料 白龙 - SO 逆向实战十三篇 # 资源工具 CyberChef - 用于加密，编码，压缩和数据分析 armconverter - ARM-HEX 转换器 r0capture - 安卓应用层抓包通杀脚本 ExAndroidNativeEmu - Python 工具 Unidbg 青春版功能有限 findhash - IDA 脚本 可以检测出哈希算法 ddddocr - Python 库 通用验证码识别库 # IDA # 通过 JNI_OnLoad 定位 Native 函数 1&#123;% tip info %&#125;仅限没有经过混淆或加密处理的样本&#123;% endtip %&#125; # Python # Python 能不能调用 so 文件的 Native 方法？ Python 也有类似 Unidbg 的工具 ExAndroidNativeEmu - Python 工具 Unidbg 青春版功能有限，但是仅限于对JAVA 层的交互极少，一旦涉及到 JNI 交互，则需要果断选择 Unidbg，在 Python 中补 JAVA 的逻辑，简直不是人该受的委屈。 # 密码学 # 加密算法大概率是开源或者魔改算法有没有快速验证的方法？ 当在分析过程中有猜测或怀疑是某加密算法时可以使用类似 findhash - IDA 脚本 可以检测出哈希算法的脚本，此脚本可检测无论是否魔改常数的 hash 算法 MD5，SHA1、SHA2。 # 汇编指令 # ARM32 有 Thumb 和 ARM 两种指令模式如何确定？ 最粗暴的方式就是试错法module.callFunction时不加 1会报错非法指令则表示是 Thumb 模式 第二个办法是从知识角度出发，ARM 模式指令总是 4 字节长度，Thumb 指令长度多数为 2 字节，少部分指令是 4 字节。 # Unidbg # Unidbg 的 Jnionload 加载出的类是乱码？ so 做了字符串的混淆或加密，以此来对抗分析人员，但字符串总是要解密的，不然怎么用呢？这个解密一般发生在 Init array 节或者 JNI OnLoad 中，又或者是该字符串使用前的任何一个时机 # 对虚拟内存进行修改 Unidbg 提供了两种方法打 Patch，简单的需求可以调用 Unicorn 对虚拟内存进行修改，如下 1234public void patchVerify()&#123; int patchCode = 0x4FF00100; // emulator.getMemory().pointer(module.base + 0x1E86).setInt(0,patchCode);&#125; 1&#123;% tip warning %&#125;需要注意的是，这儿地址可别+1了，Thumb的+1只在运行和Hook时需要考虑，打Patch可别想。&#123;% endtip %&#125; # 补环境怎么补补什么？ 我们既可以根据报错提示，在 AbstractJni 对应的函数体内，依葫芦画瓢，case &quot;xxx“。 也可以在我们的 zuiyou 类中补，因为 zuiyou 类继承了 AbstractJNI。 关于补法，有两种实践方法都很有道理 全部在用户类中补，防止项目迁移或者 Unidbg 更新带来什么问题，这样做代码的移植性比较好。 自定义 JAVA 方法在用户类中补，通用的方法在 AbstractJNI 中补，这样做的好处是，之后运行的项目如果调用通用方法，就不用做重复的修补工作。 # 如何主动调用一个 Native 函数 在 Frida 中可以使用 NativeFunction API 主动调用 123456789101112131415161718192021222324function call_65540(base_addr)&#123; // 函数在内存中的地址 var real_addr = base_addr.add(0x65541) var md5_function = new NativeFunction(real_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;int&quot;, &quot;pointer&quot;]) // 参数1 明文字符串的指针 var input = &quot;r0ysue&quot;; var arg1 = Memory.allocUtf8String(input); // 参数2 明文长度 var arg2 = input.length; // 参数3，存放结果的buffer var arg3 = Memory.alloc(16); md5_function(arg1, arg2, arg3); console.log(hexdump(arg3,&#123;length:0x10&#125;));&#125;function callMd5()&#123; // 确定SO 的基地址 var base_addr = Module.findBaseAddress(&quot;libnet_crypto.so&quot;); call_65540(base_addr);&#125;// frida -UF -l path\\hookright.js 在 Unidbg 也是类似的，只不过换一下 API 罢了，让我们来看一下 123456789101112131415161718192021222324252627282930public void callMd5()&#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(10); // arg1 String input = &quot;r0ysue&quot;; // malloc memory MemoryBlock memoryBlock1 = emulator.getMemory().malloc(16, false); // get memory pointer UnidbgPointer input_ptr=memoryBlock1.getPointer(); // write plainText on it input_ptr.write(input.getBytes(StandardCharsets.UTF_8)); // arg2 int input_length = input.length(); // arg3 -- buffer MemoryBlock memoryBlock2 = emulator.getMemory().malloc(16, false); UnidbgPointer output_buffer=memoryBlock2.getPointer(); // 填入参入 list.add(input_ptr); list.add(input_length); list.add(output_buffer); // run module.callFunction(emulator, 0x65540 + 1, list.toArray()); // print arg3 Inspector.inspect(output_buffer.getByteArray(0, 0x10), &quot;output&quot;);&#125;; 需要注意，在 Unidbg 中，同样的功能有至少两种实现和写法 ——Unicorn 的原生方法以及 Unidbg 封装后的方法，在阅读别人代码时需要灵活变通。就好比 getR0long 和emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0)，它们都是获取寄存器 R0 的数值。 # JNItrace trace 我们在参数还没完全转换完的情况下，Unidbg 就退出了 这种情况下，可能的原因有很多，但可能性较大的是两个 上下文环境缺失 样本使用某种手段检测或反制了 Unidbg 先看一下是否是上下文的问题，假设是上下文缺失，通俗的讲就是在 SO 加载后到我们的 main 函数调用前的这段时间里，样本需要调用一些函数对 SO 进行初始化，而我们没有注意也没做这个事，这导致了 Unidbg 无法顺利运行。 # 抓包 # 对于服务器校验证书如何抓包？ 安卓可以使用 r0capture - 安卓应用层抓包通杀脚本进行抓包分析。 # 验证码 # 遇到验证码验证怎么办？ 可以使用 ddddocr - Python 库 通用验证码识别库进行识别，支持老版验证码，当前验证码支持部分滑块文字点选等。 # 解混淆 &amp; 反编译对抗 # AI 如何赋能解混淆研究？ 在代码混淆对抗中，如果要训练一个模型来识别 AST JSON 数据中的混淆特征，可以考虑使用以下几种算法： 机器学习算法：可以使用监督学习算法，如支持向量机（SVM）或随机森林，这些算法可以学习混淆代码和正常代码之间的模式差异。首先需要有一个标记好的特征数据集来训练模型，然后使用训练好的模型对新的代码样本进行分类和识别。 深度学习算法：特别是卷积神经网络（CNN）或循环神经网络（RNN），这些网络能够处理序列数据并识别复杂的模式。对于处理 AST 这种树状结构的数据，图神经网络（GNN）可能是一个更合适的选择，因为它们能够更好地处理图结构数据中的依赖关系。 自然语言处理算法：尽管 AST 不是自然语言，但可以使用 BERT 等预训练的语言模型来学习代码的语义表示，进而识别混淆模式。这些模型已经在自然语言处理领域显示出强大的能力，并且可以适应不同的语言和结构化数据。 基于规则的方法：可以设计一套规则系统来检测常见的混淆技术，如变量名和函数名的重命名、控制流的改变等。这种方法可能需要专业知识来定义混淆的特征和规则。 AST 分析工具：可以使用现成的 AST 分析工具，如 Babel 或 Esprima，来解析和分析 JavaScript 代码。这些工具可以帮助识别代码中的模式和潜在的混淆技术，并可能结合机器学习算法来提高识别的准确性。 在选择算法时，需要考虑数据的规模、特征的复杂性以及所需的准确性。同时，混淆技术的不断进步也要求模型能够适应新的混淆手段。通过结合多种算法和工具，可以更有效地识别和对抗代码混淆。 云梯密码 VWzMDAwrm3s!6xx"},{"title":"android证书安装与校验相关解决办法","path":"/posts/42317.html","content":"tags: [‘证书’,‘magisk’] categories: ‘经验教程’ # Android 安装证书 # Magisk 安装证书插件（推荐） Magisk 中安装插件并重启，在手机设置安全中正常手动安装证书至用户证书，接着重启手机用户证书则会移动至系统证书。 Move_Certificates-v1.9.zip # Shell 命令安装 操作证书相关命令（kali 自带 openssl） 12345678910# 查看crt\\der格式证书openssl x509 -in FiddlerRoot.crt -inform DER -noout -text# 查看pem证书openssl x509 -in certificate.pem -inform pem -noout -text# crt/der转pemopenssl x509 -in FiddlerRoot.crt -inform DER -out certificate.pem -outform PEM# pem转der/crtopenssl x509 -in certificate.pem -inform PEM -out FiddlerRoot.der -outform DER# 计算pem证书hash值openssl x509 -subject_hash_old -in Desktop.pem 导入到系统前需要重命名证书 hash 值.0 -&gt; xxxx.0。如果存在文件名冲突，则可将 .0 改为 .1 或 .2 等等。 新开一个 cmd 执行以下命令 hash 值通过 pem 证书计算得到（上面最后一条指令） 1234567adb rootadb remountadb push xxxxxxx.0 /system/etc/security/cacerts/adb shellcd /system/etc/security/cacerts/chmod 644 xxxxxxx.0reboot"},{"title":"android逆向分析环境配置","path":"/posts/45467.html","content":"tags: [‘andorid’,‘fastboot’,‘magisk’,‘root’] categories: ‘经验教程’ # 资源文件 adb-fastboot.zip # 获取 root 权限 # Magisk magisk 中文网：https://magiskcn.com/ magisk 官网：https://magiskmanager.com/ # 环境 解锁 Bootloader 提取 boot.img (卡刷包中有) PC 端 **adb-fastboot** 环境 修补 boot.img # 安装证书 安装证书详细步骤：android 证书安装与校验相关解决办法 # 问题记录 # 小米 8 写入 boot 报错 # Write to device failed (Invalid argument) 报错详情 -&gt;** ** 原文地址 1234D:\\user\\Downloads\\adb-fastboot&gt;fastboot flash boot magisk_patched-26400_QSOWo.imgWarning: skip copying boot image avb footer (boot partition size: 0, boot image size: 45851946).Sending &#x27;boot&#x27; (44777 KB) FAILED (Write to device failed (Invalid argument))fastboot: error: Command failed 新建文件 txt 文件粘贴代码块内容，保存后修改后缀为 bat ，以管理员方式运行。 123456@echo offreg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100&quot; /v &quot;osvc&quot; /t REG_BINARY /d &quot;0000&quot; /freg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100&quot; /v &quot;SkipContainerIdQuery&quot; /t REG_BINARY /d &quot;01000000&quot; /freg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\18D1D00D0100&quot; /v &quot;SkipBOSDescriptorQuery&quot; /t REG_BINARY /d &quot;01000000&quot; /fpause 执行完后，执行写入 boot 成功。"},{"title":"Frida三板斧的安装配置与基本使用","path":"/posts/8117.html","content":"tags: [‘frida’,‘jnitrace’,‘objection’] categories: ‘经验教程’ # Frida 面向开发人员、逆向工程师和安全研究人员的动态检测工具包。 frida 文档：https://frida.re/docs/home/ # 对应版本 frida&amp;frida-tools 版本对应查看 ：frida-releases 找到你使用 frida 的版本，查看其版本下 frida-tools 的版本，它们就是对应版本。（建议多准备几个 Python 与 firda 的版本，因为它并不稳定） 12pip install frida==14.2.13pip install frida-tools==9.2.1 # frida-server 安卓手机需要安装 frida-server，版本与 frida 版本需一致，根据设备架构选择 x86 或 arm 等。 解压文件 17x x frida-server.xz 启动 frida-server 1234adb rootadb push frida-server /data/local/tmp/adb shell &quot;chmod 755 /data/local/tmp/frida-server&quot;adb shell &quot;/data/local/tmp/frida-server&quot; 测试服务 1frida-ps -U // 查看正在运行进程 显示如下内容则表示服务启动，手机重启后需要再次执行命令启动。 1234 PID NAME 1590 com.xxx.xxx13194 com.xxxx.xxxxx… # 常用命令 1frida -FU packagename -l hookscript.js # Jnitrace JNItrace 是一个基于 Frida 框架的Hook jni方法的库。https://github.com/chame1eon/jnitrace Python 安装 1pip install jnitrace // 需要frida版本14以上 # 依赖： arm、arm64、x86 或 x64 Android 设备 Frida 安装在 Android 设备上 Frida 支持 &gt; 14 使用 Python 3 和 pip 的 Linux、Mac 或 Windows 主机 # 启动命令： 两个参数分别为待分析的 SO 与 APP 包名。-l 参数可以多次使用 &lt;font style=&quot;color:rgb(70, 70, 70);background-color:rgb(253, 253, 253);&quot;&gt;-l libname.so -l libname1.so ...&lt;/font&gt; 1jnitrace -l libname.so packagename 默认使用 spawn 启动，可以通过 -m attach 设置通过 attach 启。 1jnitrace -m attach -l libname.so packagename &gt;&gt; 导出 log 日志保存至文件，控制台将不输出 log。 例： jnitrace -l libname packagename &gt;&gt; jnitrace.txt # objection # 安装 官方安装教程：https://github.com/sensepost/objection/wiki/Installation 1pip3 install -U objection 在内存中所有已加载的类中搜索包含特定关键词的类 1android hooking search classes hook java 方法 1android hooking watch class_method &lt;methodName&gt; hook java 类 1android hooking watch class &lt;classname&gt; 列出进程所有的 activity 1android hooking list activities"},{"title":"Frida相关API介绍","path":"/posts/41869.html","content":"tags: [‘frida’] categories: ‘经验教程’ # 静态 &amp; 实例方法 Hook 静态和实例方法的 hook 代码一致。 1234567891011var className = &quot;com.xxxx.xx&quot;;var funcName = &quot;func&quot;;var classObject = Java.use(className);// 静态和实例方法的hook代码一致classObject[funcName].implementation = function (x) &#123; console.log(`$&#123;className&#125; -&gt; call $&#123;funcName&#125; - param: `, x); x = &quot;param&quot;; // 修改参数 除基础类型外其他类型需要自行构造。 let result = this[funcName](x); // result = &quot;param&quot;; // 修改返回值 return result;&#125;; # 构造方法的 hook ($init) 12345var classObject = Java.use(&quot;com.xxx.xx&quot;);classObject.$init.implementation = function (a, b) &#123; console.log(`$&#123;className&#125; -&gt; call $init - param: `, a, b); return this.$init(a, b);&#125;;"},{"title":"charles移动&PC抓包配置","path":"/posts/43239.html","content":"tags: [‘charles’,‘抓包’] categories: ‘经验教程’ # 安装 charles 官网下载：https://www.charlesproxy.com/download/ # 电脑抓包 安装好证书，打开 charles 这开启端口抓包，可设置 PC 系统代理来抓包数据，但通常不推荐这么做，推荐使用 Proxy SwitchyOmega （Edge 插件 | chrome 也有此插件）来进行浏览器抓包。 # 代理设置 操作：Proxy -&gt; Proxy Settings 1. 勾选 Enable tranaparent HTTP proxying 2. 勾选 Enable SOCKS proxy # 抓取端口设置 操作：Proxy -&gt; SSL Proxying Settings 1. 勾选 Enable SSL Proxying 2. 点击 Add，添加抓取端口 __ # 安装证书 操作：Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 安装证书 -&gt; 本地计算机 -&gt; 将所有的证书都放入下列存储 -&gt; 点击浏览，选择” 受信任的根证书颁发机构” -&gt; 完成 # 移动抓包 手机和 PC 处于同一网络下，将 charles 证书安装至系统（安卓 7 以下不用），配置 WiFi 代理或者 clash 代理转发，如此即可在 PC 上抓到手机流量包了。 # 安装证书 准备安装 android 证书，按照下方步骤，显示图片弹窗后进行下一步。 Help-&gt; SSL Proxying -&gt;Install Charles Root Certificate On a Mobile Device。 手机浏览器输入地址 http://chls.pro/ssl 下载 crt 证书 安装证书详细步骤：android 证书安装与校验相关解决办法 # 手动设置代理 代理主机：PC 的 IP 地址，我这里是 WiFi 所以是 WLAN 的 IPv4 地址。 代理端口：charles -&gt; Proxy -&gt; ProxySettings -&gt; Proxies 页面中的 HTTP Proxy -&gt; Port ，默认为 8888。 # clash 配置代理转发 打开 clash 依次点击 配置 -&gt; 加号 -&gt; 文件 -&gt; 浏览文件 -&gt; 配置文件，选择 MT 管理器打开，将下面代码根据注释修改后粘贴进去，保存好，启动服务即可。（下方有操作 gif） 123456789101112131415161718192021mixed-port: 7890allow-lan: truemode: globallog-level: infoexternal-controller: 127.0.0.1:9090proxies: - name: &quot;proxy_http&quot; type: http server: 192.168.0.199 # 代理主机 port: 8888 # http代理端口 udp: true - name: &quot;proxy_socks5&quot; type: socks5 server: 192.168.0.199 # 代理主机 port: 8889 # socks代理端口 udp: trueproxy-groups:rules: 配置名称随意，启动后记得选择代理模式哦！"},{"title":"小破站老版本（入门级）SO层Native方法分析","path":"/posts/26899.html","content":"tags: [‘SO’,‘Native’,‘入门级’,‘frida’] categories: ‘逆向分析’ # 准备工作 APK：哔哩哔哩 6.13.0 首先通过 charles 抓包（charles 抓包配置）发现加密参数是 sign（32 位）。 使用 ajdx 打开 apk 后搜索 &quot;sign&quot; 并没有想要的数据，接着试着搜索 &quot;sign=&quot; 经过分析发现是 &lt;font style=&quot;color:rgb(77, 77, 77);&quot;&gt;com.bilibili.nativelibrary.LibBili.s&lt;/font&gt; 生成。 # 验证加密 使用 frida 来 hook 验证以下 1234567891011121314function hookSign() &#123; Java.perform(function () &#123; let LibBili = Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;); LibBili[&quot;s&quot;].implementation = function (sortedMap) &#123; console.log( `LibBili.s is called: sortedMap=$&#123;sortedMap.entrySet().toArray()&#125;` ); let result = this[&quot;s&quot;](sortedMap); console.log(`LibBili.s result=$&#123;result&#125;`); return result; &#125;; &#125;);&#125;setImmediate(hookSign); frida hook 日志，很明显 sign 就是在这里面生成的。 12[MI 8 Pro::tv.danmaku.bili ]-&gt; LibBili.s is called: sortedMap=access_key=null,appkey=1d8b6e7d45233436,build=6130400,c_locale=zh-Hans_CN,channel=xxl_wyyd_001,mVersion=71,mallVersion=6130400,mobi_app=android,platform=android,s_locale=zh-Hans_CN,statistics=&#123;&quot;appId&quot;:1,&quot;platform&quot;:3,&quot;version&quot;:&quot;6.13.0&quot;,&quot;abtest&quot;:&quot;&quot;&#125;LibBili.s result=access_key=&amp;appkey=1d8b6e7d45233436&amp;build=6130400&amp;c_locale=zh-Hans_CN&amp;channel=xxl_wyyd_001&amp;mVersion=71&amp;mallVersion=6130400&amp;mobi_app=android&amp;platform=android&amp;s_locale=zh-Hans_CN&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.13.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1702547190&amp;sign=83c0620895711a111a4fc8f046b76d9d # 定位 SO 使用大佬的 hook 脚本并作了点修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function hook_RegisterNatives() &#123; var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;); var addrRegisterNatives = null; for (var i = 0; i &lt; symbols.length; i++) &#123; var symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if ( symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 ) &#123; addrRegisterNatives = symbol.address; console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name); if (addrRegisterNatives != null) &#123; Interceptor.attach(addrRegisterNatives, &#123; onEnter: function (args) &#123; var env = args[0]; var java_class = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); // console.log(class_name); // 筛选类 var taget_class = &quot;com.bilibili.nativelibrary.LibBili&quot;; if (class_name === taget_class) &#123; console.log(&quot; [RegisterNatives] method_count:&quot;, args[3]); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i &lt; method_count; i++) &#123; var name_ptr = Memory.readPointer( methods_ptr.add(i * Process.pointerSize * 3) ); var sig_ptr = Memory.readPointer( methods_ptr.add( i * Process.pointerSize * 3 + Process.pointerSize ) ); var fnPtr_ptr = Memory.readPointer( methods_ptr.add( i * Process.pointerSize * 3 + Process.pointerSize * 2 ) ); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log( &quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base) ); &#125; &#125; &#125;, &#125;); &#125; &#125; &#125;&#125;setImmediate(hook_RegisterNatives); 添加筛选条件后输出的结果不多 12345678910111213Spawning `tv.danmaku.bili`...RegisterNatives is at 0xf0b3cbd9 _ZN3art3JNIILb0EE15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodiRegisterNatives is at 0xf0b910d5 _ZN3art3JNIILb1EE15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodiSpawned `tv.danmaku.bili`. Resuming main thread![MI 8 Pro::tv.danmaku.bili ]-&gt;[RegisterNatives] method_count: 0x7[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: a sig: (Ljava/lang/String;)Ljava/lang/String; fnPtr: 0xb8369c35 module_name: libbili.so module_base: 0xb8368000 offset: 0x1c35[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: ao sig: (Ljava/lang/String;II)Ljava/lang/String; fnPtr: 0xb8369c3b module_name: libbili.so module_base: 0xb8368000 offset: 0x1c3b[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: b sig: (Ljava/lang/String;)Ljavax/crypto/spec/IvParameterSpec; fnPtr: 0xb8369c49 module_name: libbili.so module_base: 0xb8368000 offset: 0x1c49[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: s sig: (Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery; fnPtr: 0xb8369c4f module_name: libbili.so module_base: 0xb8368000 offset: 0x1c4f[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: so sig: (Ljava/util/SortedMap;II)Lcom/bilibili/nativelibrary/SignedQuery; fnPtr: 0xb8369c55 module_name: libbili.so module_base: 0xb8368000 offset: 0x1c55[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: getCpuCount sig: ()I fnPtr: 0xb8369c63 module_name: libbili.so module_base: 0xb8368000 offset: 0x1c63[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: getCpuId sig: ()I fnPtr: 0xb8369c67 module_name: libbili.so module_base: 0xb8368000 offset: 0x1c67 这就是我们需要的结果，module_name: libbili.so 表示 s 函数在 libbili.so 中。 offset: 0x1c4f 偏移量为 0x1c4f 可以理解为函数起始地址。 1[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: s sig: (Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery; fnPtr: 0xb8369c4f module_name: libbili.so module_base: 0xb8368000 offset: 0x1c4f # 分析 SO 使用 file 命令查看 so 的位数是多少位，可以看到是 32 位的，那么使用 32 位的 ida 打开。 # 偏移量地址定位函数 # JNI_OnLoad 定位 s 函数"},{"title":"加速乐逆向","path":"/posts/59917.html","content":"tags: [‘解混淆’,‘加速乐’] categories: ‘逆向分析’ # 声明 本逆向文章仅为学术交流和学习探讨之用，不代表任何官方立场或观点。文章内容仅供参考，读者应自行判断其真实性和可靠性。因使用本逆向文章而产生的任何直接或间接后果，本网站及作者不承担任何法律责任。请在使用本逆向文章前仔细阅读相关法律法规和条款，并确保您理解并接受本免责声明的全部内容。如有侵权行为或不当使用，请及时联系我们，我们将尽快处理。 # 逻辑分析 1.index.html 请求中有如下图两个 cookies。 2. 使用 charles 或其他抓包工具进行抓包，看到 index.html 进过三次加载，前两次是 521 状态。 3. 第一次请求的 &lt;script&gt; 标签中进行了 cookie 设置，cookie 值如图是被混淆的。 放到浏览器控制台中执行得到如下结果，发现 cookie 的 name 和成功响应带的 cookie 一致。 4. 第二次请求带上来第一次请求的 cookies-__jsl_clearance_s, 返回结果应该经过 ob 混淆的代码。 5. 第三次成功响应，对比 cookies 发现，__jsl_clearance_s 变了，大概率是 ob 混淆文件对它做了修改。 # 请求实现 解完混淆代码逻辑清晰可见 # python 请求代码 完整代码仓库: https://github.com/Alanhays/crawler"},{"title":"TLS指纹-JA4","path":"/posts/50497.html","content":"tags: [‘JA4’,‘TLS/SSL’] categories: ‘经验教程’ # 官方解释 JA4 + 是一套易于使用和共享的网络指纹识别方法。这些方法既是人类可读的，也是机器可读的，以促进更有效的威胁搜寻和分析。这些指纹的用例包括扫描威胁参与者、恶意软件检测、会话劫持预防、合规性自动化、位置跟踪、DDoS 检测、威胁参与者分组、反向外壳检测等等。 JA4 系列 ：JA4/S/H/L/X/SSH，简称 JA4+ 官方介绍 | JA4 指纹 初始指纹： JA4 — TLS 客户端 JA4S — TLS 服务器响应 JA4H — HTTP 客户端 JA4L — 光距离 / 位置 JA4X — X509 TLS 证书 JA4SSH — SSH 流量 更多指纹正在开发中，并将在发布时添加到 JA4+ 系列中。 例子 #"},{"title":"TLS指纹-JA3","path":"/posts/1792.html","content":"tags: [‘TLS/SSL’,‘JA3’] categories: ‘经验教程’ # 官方解释 TLS 及其前身 SSL 用于为常见应用程序和恶意软件加密通信，以确保数据安全，因此可以隐藏在噪音中。要启动 TLS 会话，客户端将在 TCP 3 次握手之后发送 TLS 客户端 Hello 数据包。此数据包及其生成方式取决于构建客户端应用程序时使用的包和方法。服务器如果接受 TLS 连接，将使用基于服务器端库和配置以及 Client Hello 中的详细信息制定的 TLS Server Hello 数据包进行响应。由于 TLS 协商以明文形式传输，因此可以使用 TLS Client Hello 数据包中的详细信息来指纹和识别客户端应用程序。 官方介绍 | JA3 指纹 # JA3 原理 JA3 收集以下字段的字节的十进制值；SSL 版本、接受的密码、扩展列表、椭圆曲线和椭圆曲线格式。然后，它按顺序将这些值连接在一起，使用 “，” 分隔每个字段，使用 “-” 分隔每个字段中的每个值。 字段顺序如下： SSLVersion，密码，扩展，椭圆曲线，椭圆曲线点格式 例： 1769,47–53–5–10–49161–49162–49171–49172–50–56–19–4,0–10–11,23–24–25,0 如果客户端 Hello 中没有 SSL 扩展，则字段留空。 例： 1769,4–5–10–9–100–98–3–6–19–18–99,,, 然后对这些字符串进行 MD5 哈希处理，以生成易于使用和共享的 32 个字符的指纹。这是 JA3 SSL 客户端指纹。 12769,47–53–5–10–49161–49162–49171–49172–50–56–19–4,0–10–11,23–24–25,0 → ada70206e40642a3e4461f35503241d5769,4–5–10–9–100–98–3–6–19–18–99,,,→ de350869b8c85de67a350c8d186f11e6 我们还需要引入一些代码来解释 Google 的 GREASE（生成随机扩展和维持可扩展性），如此处所述。Google 将此用作防止 TLS 生态系统中扩展性失败的机制。JA3 完全忽略这些值，以确保使用 GREASE 的程序仍可以使用单个 JA3 哈希进行标识。 # TLS 检测判断 # TLS 检测原理 抓包工具 wireshark、charles 只能查看 TLS 指纹，不能以此判断服务器检测了 TLS。 在 HTTPS 协议中，TLS 协议是用来在客户端和服务器之间建立安全连接的，这个连接过程中就会生成 TLS 指纹。只要是 HTTPS 协议，必定会生成 TLS 指纹。 检测 TLS 是在服务端进行的，唯一判断是否检测 TLS 的手段就是测试和猜测。 # 未检测 TLS 验证请求头顺序 检测 HTTP2.0 curl 生成 code 可直接访问 … # 检测了 TLS curl、api 调试工具、js 有可响应的就 python 不行。 curl、js 都不行就浏览器可以。 … # 过校验示例 python 的 aiohttp | requests | httpx | scrapy 和 golang 相关的 ja3 指纹修改案例。 笔者整理的一些案例： JA3 指纹（go/python）点击下载"},{"title":"400行代码解混淆猿人学第二届第三题然后进行完美反编译","path":"/posts/6066.html","content":"tags: [‘AST’,‘解混淆’] categories: ‘逆向分析’ sticky: ‘8’ # 题目 猿人学 2023 届第三题 点击跳转 # 0x01 降维打击 这里 if 都是多层嵌套的，非常影响阅读体验，直接一步将它变为一维结构吧！ 还原前先手动还原小部分代码，接着写反混淆脚本批量修改。 我们单看 if (o &lt; 2) 这个 if 块，很明显 o &lt; 1 其实就是 o==0 而 else 就是 o==1 , 以此类推。 1234567891011121314151617181920212223242526272829303132333435(function (e) &#123; var o = e || 2; for (;;) if (o &lt; 2) &#123; if (o &lt; 1) &#123; o += 88; &#125; else &#123; v.v = !1; o += 226; &#125; &#125; else &#123; if (o &lt; 3) &#123; o += 243; &#125; else &#123; L = Y || l.length; o += 4; &#125; &#125;&#125;)();// 手动还原一下 还原如下(function (e) &#123; var o = e || 2; switch (o) &#123; case 0: o += 88; case 1: v.v = !1; o += 226; case 2: o += 243; case 3: L = Y || l.length; o += 4; &#125;&#125;)(); 这是我写的插件，将多层嵌套的 if 转换为 Switch 语法，可以方便我们后续调试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const IfToCase = &#123; IfStatement: &#123; exit(path, state) &#123; const &#123; test, consequent, alternate &#125; = path.node; let &#123; name, cases &#125; = state; // 如果 test 不是 o &lt; 数字，则不进行处理 if (!types.isBinaryExpression(test, &#123; operator: &quot;&lt;&quot; &#125;)) return; if (!types.isIdentifier(test.left, &#123; name: name &#125;)) return; if (!types.isNumericLiteral(test.right)) return; // alternate.body.push(types.BreakStatement()); // consequent.body.push(types.BreakStatement()); const right = test.right.value; if (right % 2 === 0) &#123; // 处理 else 不是 if 节点的情况 if (types.isIfStatement(alternate.body[0])) return; cases.push(types.SwitchCase(types.valueToNode(right), alternate.body)); return; &#125; // 构建 case 节点 const case1 = types.SwitchCase( types.valueToNode(right - 1), consequent.body ); const case2 = types.SwitchCase(types.valueToNode(right), alternate.body); cases.push(case1, case2); &#125;, &#125;,&#125;;const IfToSwitch = &#123; ForStatement(path) &#123; const &#123; init, test, update, body &#125; = path.node; const prev = path.getPrevSibling(); if (!types.isIfStatement(body)) return; const discriminant = prev.node.declarations[0].id; let cases = []; path.traverse(IfToCase, &#123; name: discriminant.name, cases: cases &#125;); if (!cases.length) return; const switchNode = types.SwitchStatement(discriminant, cases); path.get(&quot;body&quot;).replaceInline(switchNode); &#125;,&#125;; 对比效果图如下，处理后清晰了不少。 # 0x02 打回原形 经过上一步还原后发现有很多 o += xx | o -= xx 的代码，这里的 o 其实就是 case 的条件，那么简化一下吧！ o = o - xxx 其中 o - xxx 部分我们计算出来。 下面插件来喽！又香又脆，嘎嘎香！ 1234567891011121314151617181920212223const RestoreJump = &#123; AssignmentExpression(path) &#123; let &#123; operator, left, right &#125; = path.node; if (!(operator[1] === &quot;=&quot; &amp;&amp; types.isNumericLiteral(right))) return; let caseNode = path.findParent((p) =&gt; p.isSwitchCase()); let &#123; consequent, test &#125; = caseNode.node; // 构建 ast 节点 o -= xxx 改为 o - xxx , let _node = types.assignmentExpression( &quot;=&quot;, left, types.valueToNode( operator[0] === &quot;-&quot; ? test.value - right.value : test.value + right.value ) ); path.replaceInline(_node); &#125;,&#125;; 对比效果图如下，处理后清晰了不少。 # 0x03 迷阵寻踪 经过上面还原后 发现很多 case 块只做 o 的修改，那我就知道它下一步要到那个 case 块，唉！我们是不是可以将他们合并起来，插件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function getJump(node, name) &#123; if (!types.isExpressionStatement(node)) return; let &#123; expression &#125; = node; if (!types.isAssignmentExpression(expression)) return; if (expression.left.name !== name) return; return expression.right.value;&#125;function getCaseJump(map, name, node) &#123; let &#123; test, consequent &#125; = node; let list = []; let con = consequent[consequent.length - 1]; let num = getJump(con, name); if (num !== undefined) &#123; list.push(num); &#125; if (types.isIfStatement(con)) &#123; let &#123; consequent, alternate &#125; = con; let num = getJump(consequent, name); if (num !== undefined) &#123; list.push(num); &#125; num = getJump(alternate, name); if (num !== undefined) &#123; list.push(num); &#125; &#125; map[test.value] = list;&#125;function removeDuplicates(arr1, arr2) &#123; let result = []; // 存储删除的元素的数组 for (let i = 0; i &lt; arr1.length; i++) &#123; let found = false; for (let j = 0; j &lt; arr2.length; j++) &#123; if (arr1[i] === arr2[j]) &#123; result.push(arr1[i]); // 将相同的元素存储到结果数组中 arr2.splice(j, 1); // 删除arr2中的相同元素 found = true; break; &#125; &#125; if (found) &#123; arr1.splice(i, 1); // 删除arr1中的相同元素 i--; // 由于删除了元素，需要调整索引 &#125; &#125; return result;&#125;function controlFlowStructure(si, map, cases, stack = [], body = []) &#123; if (!map.loop) map.loop = []; if (stack.includes(si)) &#123; if (map.loop.indexOf(si) === -1) map.loop.push(si); return body; &#125; let item = map[si]; body = body.concat(cases[si].consequent); switch (item.length) &#123; case 0: return body; case 1: return controlFlowStructure(item[0], map, cases, stack, body); case 2: stack.push(si); body[body.length - 1].consequent = types.blockStatement( controlFlowStructure(item[0], map, cases, stack, []) ); if (map.loop.includes(si)) &#123; let &#123; test, consequent &#125; = body[body.length - 1]; body[body.length - 1] = types.whileStatement(test, consequent); body = body.concat( controlFlowStructure(item[1], map, cases, stack, []) ); &#125; else &#123; body[body.length - 1].alternate = types.blockStatement( controlFlowStructure(item[1], map, cases, stack, []) ); body = body.concat( removeDuplicates( body[body.length - 1].consequent.body, body[body.length - 1].alternate.body ) ); &#125; stack.pop(); return body; &#125;&#125;const MergeCases = &#123; SwitchStatement(path) &#123; const &#123; discriminant, cases &#125; = path.node; const name = discriminant.name; let binding = path.scope.getBinding(name); let start = binding.path.node.init.right.value; let map = &#123;&#125;; for (let i = 0; i &lt; cases.length; i++) &#123; getCaseJump(map, name, cases[i]); &#125; path.replaceInline(controlFlowStructure(start, map, cases)); &#125;,&#125;; 对比图如下，都有实质的代码了。 控制流程图 # 0x04 移除污秽 将指针修改的代码去除 123456789101112const CleaningUpGarbage = &#123; ForStatement(path) &#123; let p = path.getPrevSibling(); let name = p.node.declarations[0].id.name; path.scope.traverse(path.scope.block, &#123; AssignmentExpression(_path) &#123; if (!types.isIdentifier(_path.node.left, &#123; name: name &#125;)) return; _path.remove(); &#125;, &#125;); &#125;,&#125;; 移除无关代码 # 0x05 结构优化 优化 ifelse 结构，使其更便于阅读。 12345678910111213141516171819202122232425262728293031323334353637383940function isEndNode(nodes) &#123; let typeList = [&quot;ReturnStatement&quot;, &quot;ThrowStatement&quot;]; for (let i = 0; i &lt; nodes.length; i++) &#123; if (typeList.includes(nodes[i].type)) &#123; return true; &#125; &#125; return false;&#125;const ifOptimization = &#123; IfStatement(path) &#123; let &#123; test, consequent, alternate &#125; = path.node; if (!alternate) return; if (isEndNode(consequent.body)) &#123; path.insertAfter(alternate.body); path.node.alternate = null; &#125; else if (isEndNode(alternate.body)) &#123; path.insertAfter(consequent.body); path.replaceInline( types.ifStatement(types.unaryExpression(&quot;!&quot;, test), alternate, null) ); &#125; else if ( types.isIfStatement(consequent.body[consequent.body.length - 1]) &amp;&amp; isEndNode(consequent.body[consequent.body.length - 1].consequent.body) ) &#123; if ( generator(alternate.body[0]).code === generator(consequent.body[consequent.body.length - 1].alternate.body[0]) .code ) &#123; path.insertAfter( consequent.body[consequent.body.length - 1].alternate.body ); consequent.body[consequent.body.length - 1].alternate = null; path.node.alternate = null; &#125; &#125; &#125;,&#125;; 处理后逻辑尽现。 # 0x06 答辩还原 这里其实就是嵌套的三元表达式，先手动还原几条能发现他本质是 switch 123456789101112131415161718192021222324252627282930313233343536373839const TernaryToSwitch = &#123; ConditionalExpression(path, &#123; cases, _name &#125;) &#123; let &#123; test, consequent, alternate &#125; = path.node; if (!types.isBinaryExpression(test, &#123; operator: &quot;==&quot; &#125;)) return; let &#123; right, left &#125; = test; if (!types.isIdentifier(right) || !types.isNumericLiteral(left)) return; if (!cases[right.name]) &#123; cases[right.name] = []; &#125; let body = [ types.expressionStatement( types.assignmentExpression(&quot;=&quot;, types.identifier(_name), consequent) ), ]; body.push(types.breakStatement()); cases[right.name].push(types.switchCase(test.left, body)); &#125;,&#125;;const TernaryReturn = &#123; ReturnStatement(path) &#123; let &#123; argument &#125; = path.node; if (!types.isConditionalExpression(argument)) return; if (!types.isBinaryExpression(argument.test, &#123; operator: &quot;==&quot; &#125;)) return; let cases = &#123;&#125;; let name = argument.test.right.name; if (!name) return; let _name = `$&#123;name&#125;$&#123;path.node.start&#125;`; path.traverse(TernaryToSwitch, &#123; cases: cases, _name: _name &#125;); path.insertBefore( types.variableDeclaration(&quot;var&quot;, [ types.variableDeclarator(types.identifier(_name), null), ]) ); path.replaceInline( types.switchStatement(types.identifier(name), cases[name]) ); path.insertAfter(types.returnStatement(types.identifier(_name))); &#125;,&#125;; 对比效果图如下，处理后犹如拨云见日，茅塞顿开。（还原它主要是为了反编译 jsvmp） # 0x07 窥探本源 反编译后魔改点与环境检测清晰可见"},{"title":"GitHub Actions 的使用","path":"/posts/60496.html","content":"tags: [‘GitHub’,‘Actions’] categories: ‘精选推荐’ # 基本概念 workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 # workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。 一个库可以有多个 workflow 文件。 GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 # name 工作流的名称。GitHub 在存储库的 “Actions” 显示工作流的名称。如果省略 ，GitHub 将显示相对于存储库根目录的工作流文件路径。 1name: GitHub Actions Demo # on 定义运行工作流时的触发事件 # 使用单个事件 例如，具有以下值的工作流将在推送到工作流存储库中的任何分支时运行：on 1on: push # 使用多个事件 您可以指定单个事件或多个事件。例如，当推送到存储库中的任何分支或有人分叉存储库时，将运行具有以下值的工作流：on 1on: [push, fork] 如果指定多个事件，则只需发生其中一个事件即可触发工作流。如果同时发生工作流的多个触发事件，则将触发多个工作流运行。 # jobs.&lt;job_id&gt;.name 工作流运行中要执行的一项或多项任务 12345jobs: task1: name: The first task to be executed task2: name: The second task to execute 上面代码的 jobs 字段包含 task1、task2 任务，task1 (job_id) 里面的 name 字段是任务的说明。 # jobs.&lt;job_id&gt;.needs 用于标识在运行当前任务之前必须成功完成的一项或多项作业 123456jobs: job1: job2: needs: job1 job3: needs: [job1, job2] job1 无需等待直接执行、job2 需要等待 job1 执行完成、job3 需要等待 job1、job2 都执行完成。 示例执行流程 | job1 -&gt; job2 -&gt; job3 # jobs.&lt;job_id&gt;.runs-on runs-on 字段指定运行所需要的虚拟机环境。可用虚拟机如下（示例） ubuntu windows macos ubuntu-latest windows-latest macos-latest ubuntu-18.04 windows-2019 macos-10.14 ubuntu-22.04 windows-2022 macos-12 指定虚拟机为 ubuntu-22.04 （必填） 1runs-on: ubuntu-22.04 # jobs.&lt;job_id&gt;.steps steps 字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。 每个步骤都可以指定以下三个字段。 123jobs.&lt;job_id&gt;.steps.name：名称jobs.&lt;job_id&gt;.steps.run：运行的命令或者 actionjobs.&lt;job_id&gt;.steps.env：所需的环境变量"},{"title":"语雀编写文章一键自动部署博客至Github和Gitee","path":"/posts/31158.html","content":"tags: [‘hexo’,‘GitHub’] categories: ‘精选推荐’ description: 一键发布语雀文章至 github (hexo 博客) 和 gitee 并实现 gitee pages 自动更新。 # 前言 一键发布语雀文章至 github (hexo 博客) 和 gitee 并实现 gitee pages 自动更新。 hexo 博客示例：https://alanhays.gitee.io | https://alanhays.github.io 语雀编写文章 同步语雀文章至 hexo hexo 发布语雀文章更新博客 github actions 自动同步仓库至 gitee 并更新 pages # 部署 hexo 博客 # 安装 git 和 node (推荐 LTS 版) git 官网 -&gt; https://git-scm.com/ node 官网 -&gt; https://nodejs.org/en # 检查安装 # 安装 hexo 博客 找到一个位置，打开 **Git Bash Here** 分别执行下面命令，其中 blog 可替换为你喜欢的名字（会在当前目录新建一个文件夹） 1234npm install hexo-cli -ghexo init blogcd bloghexo s # 验证博客 浏览器打开 -&gt; http://localhost:4000/ 打开后正常显示 hexo 默认博客 # hexo 常用命令 123456789101112131415npm install hexo -g # 安装Hexonpm update hexo -g # 升级hexo init blog # 初始化博客 blog(选填) 创建一个名为blog的目录并初始化命令简写hexo n &quot;文章名&quot; == hexo new &quot;文章名&quot; # 新建文章hexo g == hexo generate # 生成hexo s == hexo server # 启动服务预览hexo d == hexo deploy # 部署hexo server # Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s # 静态模式hexo server -p xxxx # 更改端口hexo server -i xxx.xxx.x.x # 自定义IPhexo clean #清除缓存 # GitHub 创建仓库 仓库名称格式你的用户名.github.io 比如我这里应该写 alanhays.github.io # 生成秘钥 &amp; 公钥 打开 **Git Bash Here** 执行以下命令 yourname 改为你的 GitHub 的用户名 1git config --global user.name &quot;yourname&quot; youremail 改为你的注册 GitHub 时的邮箱 1git config --global user.email &quot;youremail&quot; 创建 ssh，输入命令，然后一直回车 youremail 改为你的注册 GitHub 时的邮箱 1ssh-keygen -t rsa -C &quot;youremail&quot; 在文件中找到这个路径 &lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;C:\\Users\\你的用户名\\.ssh&lt;/font&gt; 在 GitHub 的 Setting 里面，找到 SSH keys，把 id_rsa.pub（公钥） 里面的内容全部复制到 key 进去，title随便写即可。 # hexo 部署到 GitHub 在 blog 文件夹下面找到_config.yml 文件 在末尾找到 deploy 并修改（以文本格式打开 vscode 或记事本都可） yourname 改为你的GitHub 的用户名 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 打开 Git Bash Here 安装 git 部署命令工具 1npm install hexo-deployer-git --save 分别输入以下命令 12hexo ghexo d # 开启 GitHub Pages 服务 打开你的仓库 你的用户名.github.io 按照步骤操作开启 Pages 完成后等待一会，你可看到如下页面，点击 Visit site 查看你的博客 # hexo 主题配置 推荐在主题市场选择喜欢的主题，主题中都有详细的使用教程。 优质主题（排序不分先后） anzhiyu aurora shoka 主题市场 https://hexo.io/themes/ 创作主题教程 https://hexo.io/zh-cn/docs/themes.html # 同步语雀文章 项目：https://github.com/x-cold/yuque-hexo 注：教程请看项目就不赘述了 # GitHub Actions 自动同步 项目：https://github.com/yanglbme/gitee-pages-action 注：教程请看项目就不赘述了，存放 ./github/workflows/xxx.yml 位置请看本文。 # hexo 项目 GitHub Actions 存放位置 gitee 仓库依靠 GitHub Actions ./github/workflows/xxx.yml 实现 需要将 ./github/workflows/xxx.yml 放置 &lt;font style=&quot;color:rgb(31, 35, 40);&quot;&gt;.deploy_git/.github/workflows/xxx.yml&lt;/font&gt; 12./github/workflows/xxx.yml.deploy_git/.github/workflows/xxx.yml 如此 hexo d 命令推送时才会将 Actions 文件推送 # 总结 1. 使用下面命令同步语雀最新文章，其中 xxx… 为 token 或 key。 1set YUQUE_TOKEN=xxx SECRET_ID=xxx SECRET_KEY=xxx &amp;&amp; yuque-hexo sync 2. 使用以下两个命令构建和部署博客 12hexo ghexo d 执行完后等待 2-3 分钟博客就更新了，如果 github 更新了，gitee 没有那么请查看 GitHub Actions 详细日志，可能因为网络不稳定导致 GitHub Actions 执行失败，请手动执行或再次推送。 # 我的实现一键更新博客（参考） 我将变量设置为用户环境变量，相对不可见，变量名不可自定义 YUQUE_TOKEN = 你的语雀 token (可读权限) 1hexo clean &amp;&amp; yuque-hexo sync &amp;&amp; hexo g &amp;&amp; hexo algolia &amp;&amp; hexo d # 查看 GitHub Actions 详细日志"},{"title":"AST解混淆插件函数","path":"/posts/14781.html","content":"tags: [‘AST’,‘解混淆’] categories: ‘经验教程’ 存在复用性的插件与函数，不定期补充。 # 字面量解混淆 12345678910111213const simplifyLiteral = &#123; NumericLiteral(&#123; node &#125;) &#123; if (node.extra &amp;&amp; /^0[obx]/i.test(node.extra.raw)) &#123; //特征匹配 node.extra = undefined; &#125; &#125;, StringLiteral(&#123; node &#125;) &#123; if (node.extra &amp;&amp; /\\\\[ux]/gi.test(node.extra.raw)) &#123; node.extra = undefined; &#125; &#125;,&#125;; # 规范块语句 示例 123456789101112131415161718192021222324252627282930let i = 0;if (i) console.log(i);else console.log(1);for (let j = 0; j &lt; 2; j++) console.log(j);while (i &lt; 2) i++, console.log(i);const set = new Set([1, 2, 3]);for (let element of set) console.log(element);const str = &quot;Hello&quot;;for (let char of str) console.log(char);//-----------------------------------------let i = 0;if (i) &#123; console.log(i);&#125; else &#123; console.log(1);&#125;for (let j = 0; j &lt; 2; j++) &#123; console.log(j);&#125;while (i &lt; 2) &#123; i++, console.log(i);&#125;const set = new Set([1, 2, 3]);for (let element of set) &#123; console.log(element);&#125;const str = &quot;Hello&quot;;for (let char of str) &#123; console.log(char);&#125; 插件 12345678910111213141516const BlockSyntax = &#123; &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node &#125;) &#123; if (!types.isBlockStatement(node.body)) &#123; node.body = types.BlockStatement([node.body]); &#125; &#125;, IfStatement(path) &#123; let nodes = [&quot;consequent&quot;, &quot;alternate&quot;]; for (let i = 0; i &lt; nodes.length; i++) &#123; let _path = path.get(nodes[i]); if (_path.node &amp;&amp; !_path.isBlockStatement()) &#123; _path.replaceInline(types.BlockStatement([_path.node])); &#125; &#125; &#125;,&#125;;"},{"title":"AST解混淆常用API介绍","path":"/posts/35002.html","content":"tags: [‘AST’] categories: ‘经验教程’ sticky: ‘7’ 注意：解混淆插件几乎不可能做到通用所有混淆，学习 ast 才能对混淆进行还原。 # path/types (node) 的常用方法介绍 # 查看节点的源代码 path.toString() generator(node).code; 获取 path 与 node 的源代码方式。 1234567891011121314151617181920212223//babel库相关，解析，转换，构建，生产const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const types = require(&quot;@babel/types&quot;);const generator = require(&quot;@babel/generator&quot;).default;// js源代码let jsCode = `let a = &quot;hi ast&quot;;`;//转换为ast树let ast = parser.parse(jsCode);traverse(ast, &#123; VariableDeclarator(path) &#123; // 获取path源代码 console.log(&quot;path.toString: &quot;, path.toString()); const &#123; node &#125; = path; // 获取node源代码 console.log(&quot;generator: &quot;, generator(node).code); &#125;,&#125;);let &#123; code &#125; = generator(ast, (opts = &#123; jsescOption: &#123; minimal: true &#125; &#125;));// 处理后的js源代码console.log(code); # 判断节点类型 types.isVariableDeclarator(node,opts) path.isVariableDeclarator(opts) 下方 &quot;FunctionDeclaration|FunctionExpression&quot; 这样写可同时遍历当前两种或多种类型。 判断节点是否是需要处理的节点，下面例子中常用到的姿势都有提到。 12345678910111213141516171819202122232425262728let jsCode = `let a = &quot;&quot;;var b = 0;const c = 2;function d () &#123; console.log(&#x27;hi&#x27;)&#125;var e = function () &#123;\tconsole.log(&#x27;ok&#x27;)&#125;`;traverse(ast, &#123; &quot;FunctionDeclaration|FunctionExpression&quot;(path) &#123; // path方法可不传参数,默认为path.node if (path.isFunctionExpression()) return; console.log(&quot;日志1：&quot;, path.toString() + &quot;;&quot;); &#125;, VariableDeclaration(path) &#123; // 使用path方法,过滤let声明的节点 if (path.isVariableDeclaration(&#123; kind: &quot;let&quot; &#125;)) return; // 使用types方法,过滤var声明的节点,第一个参数node必填 if (types.isVariableDeclaration(path.node, &#123; kind: &quot;var&quot; &#125;)) return; console.log(&quot;日志2：&quot;, path.toString()); &#125;,&#125;); 输出结果 12345日志2： const c = 2;日志1： function d() &#123; console.log(&#x27;hi&#x27;);&#125;; # 替换节点 path.replaceInline(nodes) path.replaceWithMultiple() path.replaceWith() 推荐使用 replacelnline 方法，它兼容其他两种方法，无脑使用 replacelnline 即可。 types.valueToNode 方法可以将基础值转换为对应节点。 下面这段插件可以将所有变量的值都变为 666。 123456789101112let jsCode = `var a = 1;var b = 2;var c = 3;`;let ast = parser.parse(jsCode);traverse(ast, &#123; VariableDeclarator(path) &#123; path.replaceInline(types.valueToNode(666)); &#125;,&#125;); 输出结果 123var a = 666;var b = 666;var c = 666; # 节点删除 path.remove() 该方法没有参数，可以将路径下的节点全部删除，使用请小心。 下面示例将变量名为 a 的 path 删除了，结果是删除了 var a = 1; 这行代码。 1234567891011121314let jsCode = `var a = 1;var b = 2;var c = 3;`;let ast = parser.parse(jsCode);traverse(ast, &#123; VariableDeclarator(path) &#123; let &#123; id &#125; = path.node; if (id.name != &quot;a&quot;) return; path.remove(); &#125;,&#125;); 输出结果 12var b = 2;var c = 3; # 节点插入 path.insertBefore(nodes) //当前节点前插入 path.insertAfter(nodes) // 当前节点后插入 什么地方可以插入节点？ 一般在 [] 节点类型进行插入，你可以使用 Array 的方法来操作它，比如 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;pop&lt;/font&gt; 、 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;push&lt;/font&gt; 等等。 12345678910111213141516171819202122232425let jsCode = `var b = 1;`;traverse(ast, &#123; VariableDeclarator(path) &#123; if (path.node.id.name != &quot;b&quot;) return; let node = types.VariableDeclarator( types.Identifier(&quot;a&quot;), types.valueToNode(0) ); // types.Identifier(&quot;a&quot;) 生成Identifier类型节点 实参“a” 实际是 name = “a” // types.valueToNode 将值转换为节点 // console.log(generator(node).code) path.parent.declarations.unshift(node); // 等价于 path.insertBefore(node); // 构造节点 let node1 = types.VariableDeclarator( types.Identifier(&quot;c&quot;), types.valueToNode(2) ); let node2 = types.VariableDeclarator( types.Identifier(&quot;d&quot;), types.valueToNode(3) ); // insertBefore 和 insertAfter 都支持多个node path.insertAfter([node1, node2]); &#125;,&#125;); 输出结果 1234var a = 0, b = 1, c = 2, d = 3; # 获取父节点 path.parent path.parentPath path.parentPath 获取的是 path，path.parent 获取的是 node，他们的关系如下： 1path.parent = path.parentPath.node; # 获取子孙节点 path.get(key) 形参 key 是一个字符串，也就是路径，以。隔开。 两种方式获取子节点。 path.get获取的是 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;path&lt;/font&gt; ，需要 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;.node&lt;/font&gt; 获取节点。 12345678let jsCode = &quot;var b = 1;&quot;;traverse(ast, &#123; Program(path) &#123; let node1 = path.get(&quot;body.0.declarations.0&quot;).node; let node2 = path.node.body[0].declarations[0]; console.log(node1 === node2); &#125;,&#125;); # 获取兄弟节点 path.getPrevSibling() // 获取前一个兄弟节点 path.getAllPrevSiblings() // 获取所有的前兄弟节点 path.getNextSibling() // 获取后一个兄弟节点 path.getAllNextSiblings() // 获取所有的后兄弟节点 获取的为 path，其中 getAllPrevSiblings，getAllNextSiblings 返回 path 列表。 12345678910111213141516let jsCode = `var a = &quot;老大&quot;,b= &quot;老二&quot;, c =&quot;老三&quot;,d=&quot;老四&quot;,e=&quot;老五&quot;;`;traverse(ast, &#123; VariableDeclarator(path) &#123; if (path.node.id.name != &quot;c&quot;) return; console.log(&quot;获取前一个兄弟节点&quot;, path.getPrevSibling().toString()); console.log(&quot;获取所有的前兄弟节点&quot;, path.getAllPrevSiblings().toString()); console.log(&quot;当前节点是&quot;, path.toString()); console.log(&quot;获取后一个兄弟节点&quot;, path.getNextSibling().toString()); console.log(&quot;获取所有的后兄弟节点&quot;, path.getAllNextSiblings().toString()); &#125;,&#125;); 输出结果 12345获取前一个兄弟节点 b = &quot;老二&quot;获取所有的前兄弟节点 b = &quot;老二&quot;,a = &quot;老大&quot;当前节点是 c = &quot;老三&quot;获取后一个兄弟节点 d = &quot;老四&quot;获取所有的后兄弟节点 d = &quot;老四&quot;,e = &quot;老五&quot; # 向上查找节点 path.findParent(callback) // 从父节点查找 path.find(callback) // 从当前节点查找 find(findParent从父节点)从当前 path 开始向上遍历，直到满足回调函数条件为止，找不到则返回 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;null&lt;/font&gt; 。 123456789101112131415161718192021222324252627let jsCode = `function a() &#123; function b() &#123; function c() &#123; &#125; &#125;&#125;`;traverse(ast, &#123; FunctionDeclaration(path) &#123; const &#123; id &#125; = path.node; // 进入最内层的d if (id.name !== &quot;c&quot;) return; let find = path.find((p) =&gt; p.isFunctionDeclaration()); let findParent = path.findParent((p) =&gt; p.isFunctionDeclaration()); let findParent1 = path.findParent( (p) =&gt; p.isFunctionDeclaration() &amp;&amp; p.node.id.name == &quot;a&quot; ); let findParent2 = path.findParent( (p) =&gt; p.isFunctionDeclaration() &amp;&amp; p.node.id.name == &quot;c&quot; ); console.log(&quot;find -&gt; &quot;, find.toString()); console.log(&quot;findParent -&gt; &quot;, findParent.toString()); console.log(&quot;findParent1 -&gt; &quot;, findParent1.toString()); console.log(&quot;findParent2 -&gt; &quot;, findParent2); &#125;,&#125;); 输出结果 12345678910find -&gt; function c() &#123;&#125;findParent -&gt; function b() &#123; function c() &#123;&#125;&#125;findParent1 -&gt; function a() &#123; function b() &#123; function c() &#123;&#125; &#125;&#125;findParent2 -&gt; null # 计算表达式的值 path.evaluate() 通过evaluate可以直接帮你把结果计算出来。 12345678910let jsCode = `var a = 1+2;var b = !![];`;traverse(ast, &#123; VariableDeclarator(path) &#123; let initPath = path.get(&quot;init&quot;); const &#123; confident, value &#125; = initPath.evaluate(); if (!confident) return; initPath.replaceWith(types.valueToNode(value)); &#125;,&#125;); 输出结果 12var a = 3;var b = true; # scope&amp;binding 的用法介绍 资料来源 -&gt; 作用域 Scope - 与 - 被绑定量 Binding # 作用域 Scope &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;@Babel&lt;/font&gt; 解析出来的语法树节点对象会包含作用域信息，这个信息会作为节点 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;Node&lt;/font&gt; 对象的一个属性保存 这个属性本身是一个 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;Scope&lt;/font&gt; 对象，其定义位于 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;node_modules/@babel/traverse/lib/scope/index.js&lt;/font&gt; 中 例：查看基本的 作用域与绑定 信息 1234567891011121314151617181920212223const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const jscode = `function squire(i)&#123; return i * i * i;&#125;function i()&#123; var i = 123; i += 2; return 123;&#125;`;let ast = parser.parse(jscode);const visitor = &#123; FunctionDeclaration(path) &#123; console.log(&quot; 这里是函数 &quot;, path.node.id.name + &quot;()&quot;); path.scope.dump(); &#125;,&#125;;traverse(ast, visitor); 执行 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;Scope.dump()&lt;/font&gt; ，会得到自底向上的 作用域与变量信息 得到结果： 1234567891011121314151617这里是函数 squire()------------------------------------------------------------# FunctionDeclaration- i &#123; constant: true, references: 3, violations: 0, kind: &#x27;param&#x27; &#125;# Program- squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;- i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;------------------------------------------------------------这里是函数 i()------------------------------------------------------------# FunctionDeclaration- i &#123; constant: false, references: 0, violations: 1, kind: &#x27;var&#x27; &#125;# Program- squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;- i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;------------------------------------------------------------ 输出查看方法 每一个作用域都以#标识输出 每一个绑定都以-标识输出 对于单次输出，都是自底向上的 先输出当前作用域，再输出父级作用域，再输出父级的父级作用域…… 对于单个绑定Binding，会输出 4 种信息 constant 声明后，是否会被修改 references 被引用次数 violations 被重新定义的次数 kind 函数声明类型。param 参数，hoisted 提升，var 变量， local 内部 后续会单独说明Binding对象，此处留个印象即可 描述 此处从两个函数节点输出了其作用域的信息 这两个函数都是定义在同一级下的，所以都会输出相同的父级作用域Program的信息 你会发现，代码中有非常多个i，有的是函数定义，有的是参数，有的是变量。仔细观察它们的不同之处 解释器就是通过 不同层级的作用域 与 绑定定义信息 来区分不同的名称的量的 # 绑定 Binding &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;Binding&lt;/font&gt; 对象用于存储 绑定 的信息 这个对象会作为 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;Scope&lt;/font&gt; 对象的一个属性存在 同一个作用域可以包含多个 Binding 你可以在 &lt;font style=&quot;color:rgb(232, 62, 140);&quot;&gt;@babel/traverse/lib/scope/binding.js&lt;/font&gt;&lt;font style=&quot;color:rgb(44, 62, 80);&quot;&gt;&lt;/font&gt; 中查看到它的定义 显示 Binding 的信息 123456789101112131415161718192021222324252627282930313233343536373839const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const jscode = `function a()&#123; var a = 1; a = a + 1; return a;&#125;function b()&#123; var b = 1; var c = 2; b = b - c; return b;&#125;`;let ast = parser.parse(jscode);const visitor = &#123; BlockStatement(path) &#123; console.log(&quot; 此块节点源码： &quot;, path.toString()); console.log(&quot;----------------------------------------&quot;); var bindings = path.scope.bindings; console.log(&quot;作用域内 被绑定量 数量：&quot;, Object.keys(bindings).length); for (var binding_ in bindings) &#123; console.log(&quot;名字：&quot;, binding_); binding_ = bindings[binding_]; console.log(&quot;类型：&quot;, binding_.kind); console.log(&quot;定义：&quot;, binding_.identifier); console.log(&quot;是否会被修改：&quot;, binding_.constant); console.log(&quot;被修改信息信息记录&quot;, binding_.constantViolations); console.log(&quot;是否会被引用：&quot;, binding_.referenced); console.log(&quot;被引用次数&quot;, binding_.references); console.log(&quot;被引用信息NodePath记录&quot;, binding_.referencePaths); &#125; &#125;,&#125;;traverse(ast, visitor); 会输出一大堆信息。其对应的意义已经写在代码中，可以自行查看 # 作用 在解混淆中，作用域与绑定 主要用来处理边界的问题 即：某个量哪里引用了，在哪里定义 例：删除所有定义了，却从未使用的变量 123456789101112131415161718192021222324252627282930const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const generator = require(&quot;@babel/generator&quot;).default;const jscode = `var a = 1;var b = 2;function squire()&#123; var c = 3; var d = 4; return a * d; var e = 5;&#125;var f = 6;`;let ast = parser.parse(jscode);const visitor = &#123; VariableDeclarator(path) &#123; const func_name = path.node.id.name; const binding = path.scope.getBinding(func_name); // 如果变量没有被引用过，那么删除也没关系 // 此处不能用有无修改过进行判断，因为没有被修改过并不意味着没用 if (binding &amp;&amp; !binding.referenced) &#123; path.remove(); &#125; &#125;,&#125;;traverse(ast, visitor);console.log(generator(ast)[&quot;code&quot;]); 得到输出: 123456var a = 1;function squire() &#123; var d = 4; return a * d;&#125; 这里使用了Scope.getBinding()方法来获取Binding对象，判断其引用情况来对语法树进行修改 # 构建节点 # 不推荐的方式（需要了解） AST 在 js 看来就是一个 json 数据，说明可以构建 {} 的方式构建节点。 假设我们需要构造这段代码 var a = 0; 先使用 ASTexplorer 查看该代码的 AST。 js 源代码 var a = 0; 的 JSON 数据 1234567891011121314151617181920212223242526&#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 10, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 9, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 5, &quot;name&quot;: &quot;a&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;NumericLiteral&quot;, &quot;start&quot;: 8, &quot;end&quot;: 9, &quot;value&quot;: 0, &quot;raw&quot;: &quot;0&quot; &#125; &#125; ], &quot;kind&quot;: &quot;var&quot;&#125; 敏锐的你发现每个节点都有 start 、 end 、 type 这几个属性和其余不同的属性，这些都是必要的吗？哪些是必要的。这时需要参考 https://babeljs.io/docs/babel-types 查看哪些是必要节点。 以 VariableDeclaration 为例。 可以看到 VariableDeclaration 类型的节点有两个必要的节点（ &lt;font style=&quot;color:#DF2A3F;&quot;&gt;type&lt;/font&gt; 对于任何节点都是必须的），其中 kind 的类型为 string 值为黄色框框框住的，而 declarations 的类型则为 VariableDeclarator 数组。 再参照其他类型节点的必要参数，简化得到下面的 ast 节点。 123456789101112131415161718const astNode = &#123; type: &quot;VariableDeclaration&quot;, declarations: [ &#123; type: &quot;VariableDeclarator&quot;, id: &#123; type: &quot;Identifier&quot;, name: &quot;a&quot;, &#125;, init: &#123; type: &quot;NumericLiteral&quot;, value: 0, &#125;, &#125;, ], kind: &quot;var&quot;,&#125;;console.log(generator(astNode).code); # types 函数构造节点 手搓 ast 节点虽然不难，但是复杂的节点构建起来很冗余， types 提供了构建 node 的 function ，使用它们来构造简洁高效。如图构造函数的参数及顺序。 1234const astNode = types.variableDeclaration(&quot;var&quot;, [ types.variableDeclarator(types.identifier(&quot;a&quot;), types.numericLiteral(0)),]);console.log(generator(astNode).code); # template 快速构造节点（推荐） 使用 types.xxx 来构建节点虽然简洁了不少，但还是觉着繁琐。那么使用 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;template&lt;/font&gt; 绝对会让你眼前一亮。 假设需要构建 var a = 0,b = 1,c = 2; 使用手搓或 types.xxx 都很繁琐，那么试试新姿势吧！别忘了导包哦！ 12const template = require(&quot;@babel/template&quot;).default;let VAR_NODE = template(`var A = 0,B = 1, C = 2`); 这里定义了 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;VAR_NODE&lt;/font&gt; 变量，其中 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;A&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;B&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;C&lt;/font&gt; 类似于占位符 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;VAR_NODE&lt;/font&gt; 接收一个参数 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;&#123;&#125;&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;&#123;&#125;&lt;/font&gt; 的 &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;A&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;B&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;C&lt;/font&gt; 这几个属性需要分别构造， &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;A&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;B&lt;/font&gt; , &lt;font style=&quot;color:rgb(47, 48, 52);&quot;&gt;C&lt;/font&gt; 等价于 VariableDeclarator 节点的 id 属性，也就是 identifier 节点，直接字符串也可以（标识符类型）。 123456const astNode = VAR_NODE(&#123; A: &quot;a&quot;, B: &quot;b&quot;, C: &quot;c&quot;,&#125;);console.log(generator(astNode).code); 得到输出: 123var a = 0, b = 1, c = 2; # 特性介绍 # 同时遍历多个类型 假设需要同时遍历多个类型，可以这样写插件，这样写一个方法处理两种类型的节点。 12345678910111213let jsCode = `let a = &quot;&quot;;let b = 0;function d () &#123; console.log(&#x27;hi&#x27;)&#125;`;let ast = parser.parse(jsCode);traverse(ast, &#123; &quot;FunctionDeclaration|VariableDeclaration&quot;(path) &#123; console.log(path.toString()); &#125;,&#125;); 还可以这样写单独处理各自的类型的节点。 12345678traverse(ast, &#123; FunctionDeclaration(path) &#123; console.log(path.toString() + &quot;;&quot;); &#125;, VariableDeclaration(path) &#123; console.log(path.toString()); &#125;,&#125;); # path.traverse 注意： path.traverse !== traverse 在 path.traverse 方法中， state 参数是一个对象，用于在遍历过程中保存和传递状态信息。你可以在访问器函数中使用 state 对象来存储和更新任何你需要的信息。 state 对象在遍历开始时由 path.traverse 方法创建并传递给每个访问器函数。你可以在访问器函数中修改 state 对象，以跟踪遍历过程中的状态。这些修改将在遍历过程中保留下来，并且在访问器函数之间共享。 以下是一个示例，展示了如何在 path.traverse 中使用 state 对象： 1234567891011121314151617181920212223242526272829const traverse = require(&quot;@babel/traverse&quot;).default;const parser = require(&quot;@babel/parser&quot;);let code = `function a() &#123; function b() &#123; function c() &#123; &#125; &#125;&#125;`;let ast = parser.parse(code);let state = &#123; counter: 0 &#125;;const visitors = &#123; BlockStatement: &#123; enter(path, state) &#123; // 在进入节点之前进行操作 state.counter++; &#125;, exit(path, state) &#123; // 在离开节点之后进行操作 console.log(&quot;遍历了&quot;, state.counter, &quot;个节点&quot;); &#125;, &#125;,&#125;;traverse(ast, &#123; BlockStatement(path) &#123; path.traverse(visitors, state); &#125;,&#125;); 在上面的示例中，我们创建了一个包含 counter 属性的 state 对象，并在 enter 和 exit 访问器中使用它来跟踪遍历的节点数量。在遍历开始时，我们将 state 对象作为第三个参数传递给 path.traverse 方法。然后，在每个访问器函数中，我们都可以使用和修改 state 对象。在 enter 访问器中，我们增加了 counter 的值；在 exit 访问器中，我们打印了遍历的节点数量。 通过使用 state 对象，你可以在遍历过程中跟踪和存储任何你需要的信息，并在访问器函数中进行相应的操作。 注意 traverse 并没有 state 参数 # babel/generator babel/generator 的 options 参数包括以下几种： filename : 字符串，指定正在生成的文件的路径。 sourceMap : 可选，是一个布尔值，指示是否生成 source map。 sourceMapName : 可选，是一个字符串或函数，指定生成的 source map 的名称。 sourceFileName : 可选，是一个字符串或函数，指定源文件的名称。 sourceRoot : 可选，是一个字符串或函数，指定源文件的根目录。 moduleRoot : 可选，是一个字符串或函数，指定模块的根目录。 moduleId : 可选，是一个字符串或函数，指定生成的模块的 ID。 looseModules : 可选，是一个布尔值，指示是否使用 loose 模块模式。 esModules : 可选，是一个布尔值，指示是否使用 ES6 模块。 sourceType : 可选，是一个字符串或函数，指定源代码的类型（例如 “script” 或 “module”）。 requires : 可选，是一个数组，包含需要生成的 require 语句。 plugins : 可选，是一个数组，包含要应用的插件。 retainLines : 可选，是一个布尔值，指示是否保留行号。 comments : 可选，是一个布尔值或函数，指示是否保留注释。 compact : 可选，“auto” 或 “true” 表示启用压缩；“false” 表示禁用压缩；“true” 表示在压缩时忽略一些不必要的空白符；“紊” 表示在压缩时保留所有空白符。 minified : 可选，是一个布尔值，指示是否启用最小化。 uglify : 可选，是一个布尔值或对象，指示是否启用 UglifyJS 风格的压缩。 beautify: true 可选，启用美化输出。 asciiOnly : 可选，一个布尔值，指示是否将 Unicode 字符转换为 ASCII 字符。 quoteKeys : 可选，一个布尔值，指示是否在对象字面量中保留键名。"},{"title":"关于","path":"/about/index.html","content":"🍓 关于我 🔭 vital: For freedom ✨ Blog: alanhays.github.io 📫 E-mail: suran0617@outlook.com 🗨️ WeChat: AlanHays 📺 BiliBili: AlanHays 🎯 52pojie: alanhays 👯 About me: esse est percipi."},{"title":"友链","path":"/friends/index.html","content":"友链失联了怎么办? 添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 先友后链：先将 Faceless Blog 添加为友链。 我已满足全部条件，快告诉我如何交换友链！ 如果您没有满足上述条件，即时提交了申请也不会通过哦～ 第一步：新建 Issue 新建 GitHub Issue 按照模板格式填写并提交。 为了提高图片加载速度，建议优化头像： 打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。 将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。 第二步：添加友链并等待管理员审核 请添加本站到您的友链中： 1234title: Alanhaysurl: https://alanhays.github.ioavatar: https://imgsrc.baidu.com/forum/pic/item/024f78f0f736afc36371925cf519ebc4b745128d.pngscreenshot: https://imgsrc.baidu.com/forum/pic/item/7acb0a46f21fbe0938135a2a2d600c338744adbb.png 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。 如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"}]